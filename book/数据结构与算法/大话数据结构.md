

# 线性表

## 顺序存储结构

用一段连续的存储单元依次存储线性表的数据元素。

```js
LOC(a_i) = LOC(a_1) * (i-1) * c
```

缺点：

* 插入和删除都需要移动大量数据，时间复杂度为`O(n)`

## 链式存储结构

链表的每个结点只包含一个指针域，叫做单链表。

链表中的第一个结点的存储位置叫做头指针。

头结点：在单链表的第一个结点前附设一个结点，此结点的数据域可以不存储任何信息。

## 静态链表

是用数组描述的链表，通常数组比较大。数组的没想包含两个数据域，data和cur，cur是下一个数据元素的下标。对数组的第一个和最后一个元素有特殊处理，不存数据。第一个元素的cur是存放备用链表（数组的空闲空间）的第一个结点的下标，最后一个元素的cur存放的是第一个有数值的元素下标(初始或空表时为0)，

# 栈

是一个线性表，后进先出的线性表，简称LIFO结构。

## 栈的顺序存储结构

需要事先定义栈的大小

### 两栈共享空间

一个栈的栈底为数组的始端，另一个栈为数组的末端。

## 栈的链式存储结构

链栈：把栈顶放在单链表的头部，不需要头结点。

## 栈的应用-四则表达式的计算

### 后缀表达式法

`9+(3-1)*3+10/2`：为正常的数学表达式，我们称为中缀表达式。

`9 3 1 - 3 * + 10 2 / +`这叫后缀表达式，如何计算：遇到数字就入栈，遇到符号就将栈顶两个数弹出计算（栈顶的数作为减数、除数），然后将结果入栈，直到计算到最后。

中缀转后缀：

从左往后遍历中缀，遇到数字直接输出到后缀表达式，遇到符号，判断是否高于栈顶符号的优先级，高的化就压栈，低于或等于就弹栈，然后将此符号压栈，（遇到左括号，直接压栈，遇到右括号，弹栈到一个左括号出栈为止）。

# 队列

## 循环队列

循环队列的`front`和`rear`是数组下标

判断队列是否装满`(Q->rear + 1) % MAXSIZE == Q->front`

将指针移动至下一位 `(Q->rear + 1) % MAXSIZE`

## 链队列

`front`指向头结点，`rear`指向终端结点。

销毁队列和清空队列，销毁和清空不同 清空是free到空链表 销毁是全部free。

清空队列先让`Q->rear == Q->front`，然后`Q->front->next=null`，因为空队列是头尾指针都指向头指针，然后在循环队列开free

# 串

是由零个或多个字符组成的有限序列，又叫字符串。

## 模式匹配算法

```c
/* 返回子串T在主串S中第pos个字符之后的位置。若不存在,则函数返回值为0。 */
/* 其中,T非空,1≤pos≤StrLength(S)。 */
Status Index(String S, String T, int pos)
{
    int i,j;
    i = pos;
    j = 1;
    while(i < S[0] && j <T[0])
    {
		if(S[i] == T[j])
        {
            i++;
            j++;
		}
        else
        {
            // 这里i变化 相当于把T字符串后移来比较 pos+1
            i = i - j + 2;
            j = 1;
        }
    }
    if(j >T[0])
        return i - T[0];
    return 0;
}

```

// 如何理解 i = i - j + 2;
// 拆分为i-j 和 +2
// i - j 可以理解为

![](C:\Users\2021RUSH\Desktop\note\book\数据结构与算法\img\串-模式匹配.png)

## `KMP`模式匹配算法

1. 假设T中没有字符与第一位T[1]相等的

字符串S：`abcdosx`，字符串T：`abcdefx`，如果T中a不等于T后面所有的字符串，那么在跟S比对时，若T[2]==S[2]，那么自然T[1] != S[2]，所以就不需要T位于第二位置的判断。所以`i`可以直接等于`i = i + m`。（m表示当前T与S匹配上的个数）

2. 假设字符串T中有与第一个T[1]相等的

求next数组，next数组的推导，即对主串进行处理，如果前缀（必含第一位，不含最后一位）和后缀（必含最后一位不含第一位）一个字符相等，那么该位的k值位2，两个字符相等k值为3，n个字符相等k值就是n+1。

# 树

1. 结点拥有子树数称为结点的度。度为0的结点称为也叶结点或终端结点。树的度是树内各结点的度的最大值。
2. 结点的层次从根开始定义，根为第一层，树种结点的最大层次称为树的深度。

